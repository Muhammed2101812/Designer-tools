#!/usr/bin/env node

/**
 * Security Vulnerability Test Script
 * Tests for SQL injection, XSS, and other common security vulnerabilities
 */

const https = require('https');
const http = require('http');
const { URL } = require('url');

// SQL Injection test payloads
const SQL_INJECTION_PAYLOADS = [
  "' OR '1'='1",
  "'; DROP TABLE users; --",
  "' UNION SELECT * FROM users --",
  "admin'--",
  "admin'/*",
  "' OR 1=1#",
  "' OR 'a'='a",
  "') OR ('1'='1",
  "1' AND (SELECT COUNT(*) FROM users) > 0 --",
  "'; EXEC xp_cmdshell('dir'); --"
];

// XSS test payloads
const XSS_PAYLOADS = [
  "<script>alert('XSS')</script>",
  "<img src=x onerror=alert('XSS')>",
  "javascript:alert('XSS')",
  "<svg onload=alert('XSS')>",
  "';alert('XSS');//",
  "<iframe src=javascript:alert('XSS')>",
  "<body onload=alert('XSS')>",
  "<input onfocus=alert('XSS') autofocus>",
  "<select onfocus=alert('XSS') autofocus>",
  "<textarea onfocus=alert('XSS') autofocus>"
];

// Path traversal payloads
const PATH_TRAVERSAL_PAYLOADS = [
  "../../../etc/passwd",
  "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
  "....//....//....//etc/passwd",
  "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
  "..%252f..%252f..%252fetc%252fpasswd"
];

// Test endpoints and their expected behavior
const TEST_ENDPOINTS = [
  {
    path: '/api/user/profile',
    method: 'GET',
    testTypes: ['sql_injection', 'xss'],
    parameters: ['id', 'name', 'email']
  },
  {
    path: '/api/tools/background-remover',
    method: 'POST',
    testTypes: ['sql_injection', 'xss'],
    parameters: ['filename', 'metadata']
  },
  {
    path: '/api/stripe/create-checkout',
    method: 'POST',
    testTypes: ['sql_injection', 'xss'],
    parameters: ['plan', 'metadata']
  },
  {
    path: '/color-picker',
    method: 'GET',
    testTypes: ['xss', 'path_traversal'],
    parameters: ['color', 'format', 'file']
  }
];

class SecurityVulnerabilityTester {
  constructor(baseUrl = 'http://localhost:3000') {
    this.baseUrl = baseUrl;
    this.results = [];
    this.vulnerabilities = [];
  }

  async makeRequest(endpoint, method = 'GET', data = null, headers = {}) {
    return new Promise((resolve, reject) => {
      const url = new URL(endpoint, this.baseUrl);
      const client = url.protocol === 'https:' ? https : http;
      
      const options = {
        hostname: url.hostname,
        port: url.port,
        path: url.pathname + url.search,
        method,
        headers: {
          'User-Agent': 'SecurityTester/1.0',
          'Content-Type': 'application/json',
          ...headers
        },
        timeout: 10000
      };

      const req = client.request(options, (res) => {
        let responseData = '';
        res.on('data', chunk => responseData += chunk);
        res.on('end', () => {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            body: responseData,
            contentType: res.headers['content-type'] || ''
          });
        });
      });

      req.on('error', reject);
      req.on('timeout', () => {
        req.destroy();
        reject(new Error('Request timeout'));
      });

      if (data && (method === 'POST' || method === 'PUT')) {
        req.write(typeof data === 'string' ? data : JSON.stringify(data));
      }

      req.end();
    });
  }

  async testSQLInjection(endpoint, parameter, payload) {
    const testCases = [
      // Query parameter injection
      {
        type: 'query_param',
        url: `${endpoint.path}?${parameter}=${encodeURIComponent(payload)}`,
        method: endpoint.method
      },
      // POST body injection
      {
        type: 'post_body',
        url: endpoint.path,
        method: 'POST',
        data: { [parameter]: payload }
      }
    ];

    const results = [];

    for (const testCase of testCases) {
      try {
        const response = await this.makeRequest(
          testCase.url,
          testCase.method,
          testCase.data
        );

        const result = {
          endpoint: endpoint.path,
          parameter,
          payload,
          testType: 'sql_injection',
          injectionType: testCase.type,
          statusCode: response.statusCode,
          vulnerable: false,
          evidence: []
        };

        // Check for SQL error messages in response
        const sqlErrorPatterns = [
          /sql syntax/i,
          /mysql_fetch/i,
          /ora-\d{5}/i,
          /microsoft ole db/i,
          /odbc.*driver/i,
          /sqlite_/i,
          /postgresql/i,
          /warning.*mysql/i,
          /valid mysql result/i,
          /pg_query/i
        ];

        sqlErrorPatterns.forEach(pattern => {
          if (pattern.test(response.body)) {
            result.vulnerable = true;
            result.evidence.push(`SQL error pattern detected: ${pattern.source}`);
          }
        });

        // Check for unusual response patterns that might indicate injection
        if (response.statusCode === 500 && response.body.includes('database')) {
          result.vulnerable = true;
          result.evidence.push('Database error in 500 response');
        }

        results.push(result);

        if (result.vulnerable) {
          this.vulnerabilities.push(result);
          console.log(`üö® SQL Injection vulnerability found: ${endpoint.path} (${parameter})`);
        }

      } catch (error) {
        console.error(`Error testing SQL injection on ${endpoint.path}:`, error.message);
      }
    }

    return results;
  }

  async testXSS(endpoint, parameter, payload) {
    const testCases = [
      // Reflected XSS in query parameters
      {
        type: 'reflected_query',
        url: `${endpoint.path}?${parameter}=${encodeURIComponent(payload)}`,
        method: 'GET'
      },
      // Reflected XSS in POST body
      {
        type: 'reflected_post',
        url: endpoint.path,
        method: 'POST',
        data: { [parameter]: payload }
      }
    ];

    const results = [];

    for (const testCase of testCases) {
      try {
        const response = await this.makeRequest(
          testCase.url,
          testCase.method,
          testCase.data
        );

        const result = {
          endpoint: endpoint.path,
          parameter,
          payload,
          testType: 'xss',
          xssType: testCase.type,
          statusCode: response.statusCode,
          vulnerable: false,
          evidence: []
        };

        // Check if request was properly blocked (400 status indicates security middleware blocked it)
        if (response.statusCode === 400) {
          // Request was blocked by security middleware - this is good!
          result.vulnerable = false;
          result.evidence.push('Request properly blocked by security middleware');
          results.push(result);
          continue;
        }

        // Check if payload is reflected in response without proper encoding
        if (response.body.includes(payload)) {
          result.vulnerable = true;
          result.evidence.push('Payload reflected without encoding');
        }

        // Check for script execution indicators
        const xssIndicators = [
          /<script[^>]*>.*?<\/script>/i,
          /javascript:/i,
          /on\w+\s*=/i,
          /<iframe[^>]*src\s*=\s*["']?javascript:/i
        ];

        xssIndicators.forEach(pattern => {
          if (pattern.test(response.body)) {
            result.vulnerable = true;
            result.evidence.push(`XSS pattern detected: ${pattern.source}`);
          }
        });

        // Check Content-Type header for proper XSS protection
        const contentType = response.headers['content-type'] || '';
        if (contentType.includes('text/html') && !response.headers['x-content-type-options']) {
          result.evidence.push('Missing X-Content-Type-Options header');
        }

        results.push(result);

        if (result.vulnerable) {
          this.vulnerabilities.push(result);
          console.log(`üö® XSS vulnerability found: ${endpoint.path} (${parameter})`);
        }

      } catch (error) {
        console.error(`Error testing XSS on ${endpoint.path}:`, error.message);
      }
    }

    return results;
  }

  async testPathTraversal(endpoint, parameter, payload) {
    const url = `${endpoint.path}?${parameter}=${encodeURIComponent(payload)}`;
    
    try {
      const response = await this.makeRequest(url, endpoint.method);

      const result = {
        endpoint: endpoint.path,
        parameter,
        payload,
        testType: 'path_traversal',
        statusCode: response.statusCode,
        vulnerable: false,
        evidence: []
      };

      // Check for file system access indicators
      const pathTraversalIndicators = [
        /root:.*:0:0:/,  // /etc/passwd content
        /\[boot loader\]/i,  // Windows boot.ini
        /\[drivers\]/i,  // Windows system files
        /#.*localhost/,  // hosts file content
      ];

      pathTraversalIndicators.forEach(pattern => {
        if (pattern.test(response.body)) {
          result.vulnerable = true;
          result.evidence.push(`Path traversal pattern detected: ${pattern.source}`);
        }
      });

      if (result.vulnerable) {
        this.vulnerabilities.push(result);
        console.log(`üö® Path traversal vulnerability found: ${endpoint.path} (${parameter})`);
      }

      return result;

    } catch (error) {
      console.error(`Error testing path traversal on ${endpoint.path}:`, error.message);
      return null;
    }
  }

  async runSecurityTests() {
    console.log('üõ°Ô∏è  Starting security vulnerability tests...\n');

    for (const endpoint of TEST_ENDPOINTS) {
      console.log(`Testing endpoint: ${endpoint.path}`);

      for (const parameter of endpoint.parameters) {
        // Test SQL Injection
        if (endpoint.testTypes.includes('sql_injection')) {
          console.log(`  Testing SQL injection on parameter: ${parameter}`);
          for (const payload of SQL_INJECTION_PAYLOADS.slice(0, 3)) { // Test first 3 payloads
            const results = await this.testSQLInjection(endpoint, parameter, payload);
            this.results.push(...results);
          }
        }

        // Test XSS
        if (endpoint.testTypes.includes('xss')) {
          console.log(`  Testing XSS on parameter: ${parameter}`);
          for (const payload of XSS_PAYLOADS.slice(0, 3)) { // Test first 3 payloads
            const results = await this.testXSS(endpoint, parameter, payload);
            this.results.push(...results);
          }
        }

        // Test Path Traversal
        if (endpoint.testTypes.includes('path_traversal')) {
          console.log(`  Testing path traversal on parameter: ${parameter}`);
          for (const payload of PATH_TRAVERSAL_PAYLOADS.slice(0, 2)) { // Test first 2 payloads
            const result = await this.testPathTraversal(endpoint, parameter, payload);
            if (result) this.results.push(result);
          }
        }

        // Small delay between tests
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
  }

  generateReport() {
    const summary = {
      totalTests: this.results.length,
      vulnerabilitiesFound: this.vulnerabilities.length,
      testsByType: {},
      vulnerabilitiesByType: {}
    };

    // Count tests and vulnerabilities by type
    ['sql_injection', 'xss', 'path_traversal'].forEach(type => {
      summary.testsByType[type] = this.results.filter(r => r.testType === type).length;
      summary.vulnerabilitiesByType[type] = this.vulnerabilities.filter(v => v.testType === type).length;
    });

    console.log('\nüõ°Ô∏è  Security Test Summary:');
    console.log(`Total tests performed: ${summary.totalTests}`);
    console.log(`Vulnerabilities found: ${summary.vulnerabilitiesFound}`);
    
    if (summary.vulnerabilitiesFound === 0) {
      console.log('‚úÖ No security vulnerabilities detected');
    } else {
      console.log('‚ùå Security vulnerabilities detected:');
      
      Object.entries(summary.vulnerabilitiesByType).forEach(([type, count]) => {
        if (count > 0) {
          console.log(`  ${type.replace('_', ' ').toUpperCase()}: ${count} vulnerabilities`);
        }
      });

      console.log('\nüö® Vulnerability Details:');
      this.vulnerabilities.forEach((vuln, index) => {
        console.log(`${index + 1}. ${vuln.testType.toUpperCase()} - ${vuln.endpoint}`);
        console.log(`   Parameter: ${vuln.parameter}`);
        console.log(`   Payload: ${vuln.payload}`);
        vuln.evidence.forEach(evidence => {
          console.log(`   Evidence: ${evidence}`);
        });
        console.log('');
      });
    }

    // Save detailed report
    const fs = require('fs');
    const path = require('path');
    const reportPath = path.join(process.cwd(), 'security-vulnerability-report.json');
    
    fs.writeFileSync(reportPath, JSON.stringify({
      timestamp: new Date().toISOString(),
      baseUrl: this.baseUrl,
      summary,
      vulnerabilities: this.vulnerabilities,
      allResults: this.results
    }, null, 2));

    console.log(`üìÑ Detailed report saved to: ${reportPath}`);
    
    return summary.vulnerabilitiesFound === 0;
  }
}

// CLI execution
if (require.main === module) {
  const baseUrl = process.argv[2] || 'http://localhost:3000';
  
  (async () => {
    try {
      const tester = new SecurityVulnerabilityTester(baseUrl);
      await tester.runSecurityTests();
      const allPassed = tester.generateReport();
      
      process.exit(allPassed ? 0 : 1);
    } catch (error) {
      console.error('‚ùå Security vulnerability test failed:', error);
      process.exit(1);
    }
  })();
}

module.exports = SecurityVulnerabilityTester;